package name.tonny.processing.bezier;

import java.util.LinkedList;
import java.util.List;
import java.util.Random;

import processing.core.PApplet;
import processing.core.PVector;

public class Vector {
	private PVector startPoint;
	private PVector endPoint;
	
	/**
	 * Line color of the line generated by mouse clicked
	 */
	private static final int LINE_COLOR = 0xFF0000F0 ;
	
	/**
	 * used to generate random color
	 */
	private static final int max=255;
    private static final int min=10;
    private static final Random random = new Random();
    
	public Vector() {
	}

	public Vector(PVector startPoint, PVector endPoint) {
		this.startPoint = startPoint;
		this.endPoint = endPoint;
	}
	
	public PVector getStartPoint() {
		return startPoint;
	}

	public void setStartPoint(PVector startPoint) {
		this.startPoint = startPoint;
	}

	public PVector getEndPoint() {
		return endPoint;
	}

	public void setEndPoint(PVector endPoint) {
		this.endPoint = endPoint;
	}

	public void drawLine(PApplet applet) {
		applet.stroke(Vector.LINE_COLOR);
		applet.line(startPoint.x, startPoint.y, endPoint.x, endPoint.y);
	}
	
	public static void drawLineInList(List<Vector> list, PApplet applet) {
		for (Vector v : list)
			v.drawLine(applet);
	}
	
	/**
	 * Add new element(Vector) into the list
	 * if there's no elementin the list, then create a new one with the same start and end and add it into the list
	 * @param list
	 * @param point
	 * @return
	 */
	public static List<Vector> addVector(List<Vector> list, PVector point) {
		if (list.size() == 0)
			list.add(new Vector(point, point));
		else {
			Vector last = list.get(list.size() - 1);
			Vector newLast = new Vector(last.getEndPoint(), point);
			list.add(newLast);
		}
		return list;
	}
	
	/**
	 * Draw the Bezier curve using recursion method
	 * @param list the point list of all mouse clicked
	 * @param applet
	 * @param step with the same meaning of variant t in the equation of  Bezier curve
	 * @return boolean
	 */
	public static boolean drawBezier(List<Vector> list, PApplet applet, float step) {
		if (step >= 1.0)
			return false;
		if (list.size() < 1) 
			return false;
		if (list.size() == 1) {
			PVector p1 = list.get(0).startPoint;
			PVector p2 = list.get(0).endPoint;
			PVector p = PVector.lerp(p1, p2, step);
			applet.stroke(255,255,255);
			applet.ellipse(p.x, p.y, 1, 1);
			return true;
		} else {
			List<Vector> tempList = new LinkedList<Vector>();
			for (int i = 0; i < list.size() - 1; ) {
				PVector p1 = list.get(i).startPoint;
				PVector p2 = list.get(i++).endPoint;
				PVector p = PVector.lerp(p1, p2, step);
				p1 = list.get(i).startPoint;
				p2 = list.get(i).endPoint;
				PVector t = PVector.lerp(p1, p2, step);
				applet.stroke(random.nextInt(max)%(max-min+1) + min, random.nextInt(max)%(max-min+1) + min, random.nextInt(max)%(max-min+1) + min);
				applet.line(p.x, p.y, t.x, t.y);
				tempList.add(new Vector(p, t));
			}
			drawBezier(tempList, applet, step);
			return true;
		}
	}
}
